---
title: "ggplot2_CH3"
author: "Jingyang(Judy) Zhang"
date: "3/31/2020"
output: html_document
---
# CH3 Toolbox #

## 3.1 Introduction ##
```{r}
library(tidyverse)
library(reshape)
library(ggpubr)
library(nlme)
```

1. In general, there are __three__ purposes for a layer:

a. <strong>To Display the Data:</strong> pattern detection on spot gross structure, local structure, and outliers. 

b. <strong>To Display a Statistical Summary of the Data:</strong> displaymodel predictions in the context of the data. 

(1) Showing the data helps us imrpove the model

(2) Showing the model helps us reveal subtleties of the data that might otherwise miss. 

(3) Summaries are usually drawn on top of the data. 

c. <strong>To Add Additional Metadata:</strong> context, annotations, and references. 

(1) A metadata layer displays background context, annotations that help to give meaning to the raw data, or fixed references that aid comparisons across panels. 

(2) Metadata can be useful in the background and foreground. 
(a) A map is often used as a background layer with spatial data. 

(b) Background metadata should be rendered so that it does not interfere with your perception of the data, so is usually displayed underneath the data and formatted so that it is minimally perceptible. 

(3) Other metadata is used to highlight important features of the data such as render inflection points or outliers so that they pop out at the viewer. This should be the very last layer drawn. 


## 3.2 Basic Plot Types

1. Basic plot type geoms are the fundamental building blocks of ggplot2. 

a. Most of these geoms are associated with a named plot: when that geom is used by itself in a plot, that plot has a special name. 

b. Each of these geoms is two dimensional and requires both $x$ and $y$ aesthetics. 

c. All of these geoms understand ``color`` and ``size`` aesthetics, and the filled geoms (bar, tile, polygon) and also understand ``fill``.

2. Basic Plot Types Geoms

a. ``geom_area()``: draws an __area plot__, which is a line plot filled to the y-axis (filled lines). 

(1) Multiple groups will be stacked on top of each other. 

b. ``geom_bar(stat="identity")``: makes a __bar chart__. 

(1) Need ``stat="identity"`` as the default stat autmatically counts the values (so is essentially a 1d geom). 

(2) The identity stat leaves the data unchanged. 

(3) Multiple bars in the same location will be stacked on top of one another. 

c. ``geom_line()``: makes a __line plot__.

(1) The ``group`` aesthetic determines which observations are connected. 

(2) ``geom_line()`` connects points from __left to right__. 

(3) ``geom_path()`` connects points in the order they appear in the data. 

(4) Both ``geom_line()`` and ``geom_path()`` understand the aesthetic ``linetype``, which maps a categorical variable to solid, dotted and dashed lines. 


d. ``geom_point()``: produces a __scatterplot__.

(1) ``geom_point()`` also understands the ``shape`` aesthetic. 

e. ``geom_polygon()``: draws __polygons__, <u>which are filled paths</u>. 

(1) Each vertex of the polygon requires a separate row in the data. 

(2) It is often useful to merge a data frame of polygon coordinates with the data just prior to plotting. 

f. ``geom_rect()``, ``geom_tile()``, ``geom_raster()``: draw __rectangles__. 

(1) ``geom_rect()`` is parametrised by the four corners of the rectangle, ``xmin``, ``ymin``, ``xmax``, ``ymax``.

(2) ``geom_tile()`` is exactly the same but parametrised by the center of the rect and its size, ``x``, ``y``, ``width``, ``height``.

(3) ``geom_raster()`` is a fast special case of ``geom_tile()`` used when all the tiles are the same size. 



```{r}
df=data.frame(
  x=c(3,1,5),
  y=c(2,4,6),
  label=c("a","b","c")
)

p=ggplot(df, aes(x,y,label=label))+
  labs(x=NULL, y=NULL)+ # Hide axis label
  theme(plot.title=element_text(size=12)) # Shrink plot title
  
```


```{r}
p+geom_point()+ggtitle("point")

p+geom_text()+ggtitle("text")

p+geom_bar(stat="identity")+ggtitle("bar")

p+geom_tile()+ggtitle("raster")

p+geom_line()+ggtitle("line")

p+geom_area()+ggtitle("area")

p+geom_path()+ggtitle("path")

p+geom_polygon()+ggtitle("polygon")

```


### 3.2.1 Exercises ###
1. What geoms would you use to draw each of the following named plots?

a. Scatterplot: ``geom_point()``

b. Line Chart: ``geom_line()``

c. Histogram: ``geom_histogram()``

d. Bar Chart: ``geom_bar(stat="identity")``

e. Pie Chart: ``geom_bar(stat="identity")``
```{r}
# Create Data
data <- data.frame(
  group=LETTERS[1:5],
  value=c(13,7,9,21,2)
)

# Basic piechart
ggplot(data, aes(x="", y=value, fill=group)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  
  theme_void() # remove background, grid, numeric labels
```


2. What is the difference between ``geom_path()`` and ``geom_polygon()``? What is the difference between ``geom_path()`` and ``geom_line()``?


Difference between ``geom_path()`` and ``geom_polygon()``: ``geom_path()`` connects points in the order they appear in the data while ``geom_polygon()`` draws polygons, which are filled paths. 


Difference between ``geom_path()`` and ``geom_line()``: ``geom_line()`` connects points from left to right while ``geom_path()`` connects points in the order they appear in the data. 


3. What low-level geoms are used to draw ``geom_smooth()``? What about ``geom_boxplot()`` and ``geom_violin()``?

``geom_smooth()``: ``geom_line()``

``geom_boxplot``: ``geom_rect()``

``geom_violin()``: ``geom_polygon()``




## 3.3 Labels ~~

1. ``geom_text()``: main tool to add ``labels`` at the specified ``x`` and ``y`` positions.

a. ``geom_text()`` has the most aesthetics of any geom.

(1) ``family``: gives the name of a font. 

(a) There are only three fonts that are guarantted to work everywhere __"sans"__ (the default), __"serif"__, or __"mono"__.

```{r}
df=data.frame(x=1, y=1:3, family=c("sans", "serif", "mono"))

ggplot(df, aes(x,y))+
  geom_text(aes(label=family, family=family))

```


(2) ``fontface``: specifies the face: __"plain"__ (the default), __"bold"__, or __"italic"__.

```{r}
df=data.frame(x=1, y=3:1, face=c("plain", "bold", "italic"))

ggplot(df, aes(x,y))+
  geom_text(aes(label=face, fontface=face))
```


(3) ``hjust`` and ``vjust``: adjust the alighment of text. 

(a) ``hjust`` takes values __"left"__, __"center"__, __"right"__, __"inward"__, __"outward"__. 


(b) ``vjust`` takes values __"bottom"__, __"middle"__, __"top"__, __"inward"__, __"outward"__.

(c) The default alignment is centered. 

(d) One of the most useful alignments is __"inward"__: it aligns text towards the middle of the plot. 


```{r}
df=data.frame(
  x=c(1,1,2,2,1.5),
  y=c(1,2,1,2,1.5),
  text=c("bottom-left", "bottom-right", "top-left", "top-right", "center")
)

ggplot(df, aes(x,y))+
  geom_text(aes(label=text))

ggplot(df, aes(x,y))+
  geom_text(aes(label=text), vjust="inward", hjust="inward")

# Note: hjust and vjust are aesthetics meaning they can be put in aes() function but they do not have to be in aes() function like the case above. 

```

(4) ``size``: controls the font size. 

(a) ggplot2 uses mm rather than the usual points (pts). This makes it consistent with other size units in ggplot2. 

(b) There are 72.27 pts in a inch, so to convert from points to mm, just multiply by $72.27/25.4$.

(5) ``angle``: specifies the rotation o f the text in degrees. 


b. ``geom_text()`` has three parameters. Unlike aesthetics, these only take single values, so they must be the same for all labels. 

(1) ``nudge_x``, (2) ``nudge_y``: nudge the text a little horizontally or vertically.

```{r}
df=data.frame(trt=c("a","b","c"), resp=c(1.2,3.4,2.5))



ggplot(df, aes(resp, trt))+
  geom_point()+
  geom_text(aes(label=paste0("(",resp,")")))+
  xlim(1,3.6)

ggplot(df, aes(resp, trt))+
  geom_point()+
  geom_text(aes(label=paste0("(",resp,")")), nudge_y=-0.25)+
  xlim(1,3.6) # manually tweaked the x-axis to make sure all the text fit on the plot

```

(3) ``check_overlap=TRUE``: overlapping labels will be automatically removed.

(a) Algorithm: labels are ploted in the order they appear in the data frame; if a label would overlap with an existing point, it is omitted. 

```{r}
ggplot(mpg, aes(displ, hwy))+
  geom_text(aes(label=model))+
  xlim(1,8)



ggplot(mpg, aes(displ, hwy))+
  geom_text(aes(label=model), check_overlap=TRUE)+
  xlim(1,8)
```


2. ``geom_label()``: a variation on ``geom_text()``. It draws a rounded rectangle behind the text. It is useful for adding labels to plots with busy backgrounds. 
```{r}
label=data.frame(waiting=c(55,80), eruptions=c(2,4.3), label=c("peak one","peak two"))

ggplot(faithfuld, aes(waiting, eruptions))+
  geom_tile(aes(fill=density))+
  geom_label(data=label, aes(label=label))
```


3. Challenges of Labelling Data

a. Text does not affect the limits of the plot. A label has an absolute size, regardless of the size of the plot.

b. If you want to label many points, it is difficult to avoid overlaps. ``check_overlap=TRUE`` offers little control over which labels are removed. 

(1) If all else fails, you may need to manually label points in a drawing tool. 

4. Text labels can also serve as an alternative to a legend. This usually makes the plot easier to read as it puts the labels closer to the data. 

a. The ``directlabels`` package provides a number of tools to add labels directly to the plot. 

```{r}
ggplot(mpg, aes(displ, hwy, color=class))+
  geom_point()


ggplot(mpg, aes(displ, hwy, color=class))+
  geom_point(show.legend = FALSE)+
  directlabels::geom_dl(aes(label=class), method="smart.grid") # smart.grid is a reasonable place to start for scatterplots
```



## 3.4 Annotations ##
1. Annotations add metadata to your plot. But metadata is just data, so you can use:

a. ``geom_text()``: add text descriptions or to label points. Labelling outliers and other important points is very useful. 

b. ``geom_rect()``: highlight interesting rectangular regions of the plot. 

(1) ``geom_rect()`` has aesthetics ``xmin``, ``xmax``, ``ymin``, ``ymax``.

c. ``geom_line()``, ``geom_path()``, ``geom_segment()``: to add lines. 

(1) All these geoms have an ``arrow`` parameter, which allows you to place an arrowhead on the line. Create arrowheads with ``arrow()``, which has arguments ``angle``, ``length``, ``ends``, ``type``.

d. ``geom_vline()``, ``geom_hline()``, ``geom_abline()``: allow you to add reference lines (somtimes called rules), that span the full range of the plot. 

2. Either put annotations in the foreground (using ``alpha`` if needed so you can still see the data), or in the background. 

a. The default is in the background. 

```{r}
# Time series of unemploytment
ggplot(economics, aes(date, unemploy))+
  geom_line()
```

b. The use ``-Inf`` and ``Inf`` as positions. These refer to the top and bottom (or left and right) limits of the plot. 



```{r}
# Annotate the time series with which president was in power at the time

presidential=subset(presidential, start>economics$date[1])

ggplot(economics)+
  geom_rect(
    aes(xmin=start, xmax=end, fill=party),
    ymin=-Inf, ymax=Inf, alpha=0.2, data=presidential
  )+
  geom_vline(
    aes(
      xintercept=as.numeric(start)
    ),
    data=presidential,
    color="grey50", alpha=0.5
  )+geom_text(
    aes(x=start, y=2500, label=name),
    data=presidential,
    size=3, vjust=0, hjust=0, nudge_x=50
  )+geom_line(aes(date, unemploy))+
  scale_fill_manual(values=c("blue", "red"))

```



```{r}
# Add a single annotation to a plot: have to create a one row data frame

yrng=range(economics$unemploy)
xrng=range(economics$date)

caption=paste(strwrap("Unemployment rates in the US have varied a lot over the year", 40), collapse="\n")


ggplot(economics, aes(date, unemploy))+
  geom_line()+
  geom_text(
    aes(x,y,label=caption),
    data=data.frame(x=xrng[1],y=yrng[2],caption=caption),
    hjust=0, vjust=1, size=4
  )


# Easier to use the annotate() helper function which creates the data frame for you

ggplot(economics, aes(date, unemploy))+
  geom_line()+
  annotate("text", x=xrng[1], y=yrng[2], label=caption, hjust=0, vjust=1, size=4)


```

3. Annotations, particularly reference lines, are also useful when comparing groups across facets. 

```{r}

# Without reference lines
ggplot(diamonds, aes(log10(carat), log10(price)))+
  geom_bin2d()+
  facet_wrap(~cut, nrow=1)


# With reference lines

mod_coef=coef(lm(log10(price)~log10(carat), data=diamonds))

ggplot(diamonds, aes(log10(carat), log10(price)))+
  geom_bin2d()+
  geom_abline(intercept=mod_coef[1], slope=mod_coef[2], color="white", size=1)+
  facet_wrap(~cut, nrow=1)
```

4. Left-Justify, Centered, Right-Justify:

In the ``annotate()`` function, use ``hjust`` argument to control the horizontal justification:

a. __Left-justified__: ``hjust=0``

a. __Centered__: ``hjust=0.5``

a. __Right-justified__: ``hjust=1``

## 3.5 Collective Geoms ##
1. Geoms can be roughly divided into two types:

a. __Individual Geom__: draws a distinct graphical object for EACH observation (row). 

(1) For exaple, the point geom draws one point per row. 

b. __Collective Geom__: displays ultiple observations with one geometric object. 

(1) For example, this may be a result of a statistical summary, like a boxplot.

(2) Or this may be fundamental to the display of the geom, like a polygon. 

2. __Lines__ and __Paths__: fall somewhere in between individual geom and collective geom:

a. Each line is composed of a set of straight segments, but each segment represents two points. 


3. __Group__ Aesthetic: control the assignment of observations to graphical elements. 

a. By default, the ``group`` aesthetic is mapped to the interaction of all discrete variables in the plot.

(1) This often partitions the data correctly.

(2) If it does NOT partition the data correctly or when NO discrete variable is used in a plot, need to explicitly definthe grouping structure by mapping ``group`` to a variable that has a different value for each group. 

### 3.5.1. Multiple Groups, One Aesthetic ###

1. Separate data into groups, but render them in the same way. That is, want to be able to distringuish individual subjects, but NOT identify them. 

a. Commonly used in longitudinal studies with many subjects. 

b. Plots are often called __Spaghetti Plots__.

```{r}

ggplot(Oxboys, aes(age, height, grou=Subject))+
  geom_point()+
  geom_line()
```


c. If a group is NOT defined by a single variable, but instead by a combination of multiple variables, use __interaction()__ to combine them, e.g. ``aes(group=interaction(school_id, student_id))``.


### 3.5.2 Different Groups on Different Layers ###
1. Plot summaries that use different levels of aggregation: one layer might display individuals, while another displays the overall summary. 

a. Put Grouping in the Top Layer (i.e. ``ggplot()`` layer): grouping in the top layer controls BOTH the display of the geoms, and the operation of the stats: one statistical transformation if run for EACH group. Setting ``group`` in the top layer will aply to all subsequent layers. 

```{r}
ggplot(Oxboys, aes(age, height, group=Subject))+
  geom_line()+
  geom_smooth(method="lm", se=FALSE)+
  ggtitle("Wrong Graph")
```


b. Put Grouping in a Specific Subsequent Layer: putting ``group`` to a specific subsequent layer then it will apply only to that layer. 

```{r}
ggplot(Oxboys, aes(age, height))+
  geom_line(aes(group=Subject))+
  geom_smooth(method="lm", size=2, se=FALSE)+
  ggtitle("Correct Graph")

# Note: there is no discrete variable in the plot (both weight and height are cts) so the default grouping variable will be a constant and we get one smooth. 
```


### 3.5.3 Overriding the Default Grouping ###

1. Some plots have a discete ``x`` scale, but you still want to draw lines connecting __across__ groups. 

a. This is the strategy used in __interaction plots__, __profile plots__, and __parallel coordinate plot__, among others. 


b. For discrete ``x``, to overlay lines that connect each unique ``x`` value, we need to __override the grouping__. 

```{r}
ggplot(Oxboys, aes(Occasion, height))+
  geom_boxplot()+
  geom_line(aes(group=Subject), color="#3366FF", alpha=0.5)
```



## 3.5.4 Matching Aesthetics to Graphic Objects ##

1. Issue with Collective Geom: how the aesthetics of individual observations are mapped to the aesthetics of the complete entity. 

a. Line and Paths: operate on an __off-by-one__ principle: there is one more observation than line segment, and so the aesthetic for the first observation is used for the first segment, the second observation for the second segment and so on. 

(1) __off-by-on__ principle means the aesthetic for the last observation is NOT used. 


2. Example (Off By One Principle)
```{r}


df=data.frame(x=1:3, y=1:3, color=c(1,3,5))


# Treat color as a factor
ggplot(df, aes(x,y, color=factor(color)))+
  geom_line(aes(group=1), size=2)+
  geom_point(size=5)

# Treat color as numerical/cts
ggplot(df, aes(x,y, color=color))+
  geom_line(aes(group=1), size=2)+
  geom_point(size=5)
```



__Example__ (Linear Interpolation)

The following code makes everything cts and making sure EACH point has an ``x`` and ``y`` and color. 

If you had a categorical variable but you want to make it cts in color, then use the following code. 
```{r}
xgrid=with(df, seq(min(x), max(x), length=50))

interp=data.frame(
  x=xgrid,
  y=approx(df$x, df$y, xout=xgrid)$y,
  color=approx(df$x, df$color, xout=xgrid)$y
)


ggplot(df, aes(x,y, color=color))+
  geom_line(size=2)+
  geom_point(size=5)

ggplot(interp, aes(x,y, color=color))+
  geom_line(size=2)+
  geom_point(data=df,size=5)
```

(2) Limitation for Paths and Lines: line type must be constant over each individual line. In R there is no way to draw a line whivh has varying line type. 


b. All Other Collective Geoms (e.g. polygons): the aesthetics from the individual components are only used if they are all the same, ow the default value is used. 

(1) These issues are most relevant when mapping aesthetics to cts variables.

(a) When introduce a mapping to a __discrete variable__: will by default split apart collective geoms into smaller pieces. This works particularly well for bar nad area plots, as stacking the individual pieces produces the SAME shape as the original ungroupd data.

4. Example (Mapping Aesthetics to Discrete Variable)

```{r}
ggplot(mpg, aes(class))+
  geom_bar()


# drv is a discrete variable
ggplot(mpg, aes(class, fill=drv))+
  geom_bar()


```

(b) When introduce a mapping to a __continuous variable__: the default grouping will only be based on ``class`` (the variable that is discrete but is NOT the variable that we map to ``fill`` aesthetic). 

(1) To show multiple colors, we need multiple bars for each ``class``, whcih we can get by overriding the grouping:

5. Example (Mapping Aesthetic to Continuous Variable)

```{r}
# Not working as hwy is a cts variable
ggplot(mpg, aes(class, fill=hwy))+
  geom_bar()+
  ggtitle("Wrong Plot")


ggplot(mpg, aes(class, fill=hwy, group=hwy))+
  geom_bar()+
  ggtitle("Correct Plot")
```

The bars will be stacked in the order defined by the grouping variable. If you need fine control, need to create a factor with levels ordered as needed. 


### 3.5.5 ### Exercises


## 3.6 Surface Plots ##

1. ggplot2 does NOT support true 3d surfaces but it does support many common tools for representing ed surfaces in 2d.

a. __Contours__

b. __Coloured Tiles__

c. __Bubble Plots__: work better with fewer observations

```{r}
ggplot(faithfuld, aes(eruptions, waiting))+
  geom_contour(aes(z=density, color=..level..))


ggplot(faithfuld, aes(eruptions, waiting))+
  geom_raster(aes(fill=density))


small=faithfuld[seq(1, nrow(faithfuld), by=10),]

ggplot(small, aes(eruptions, waiting))+
  geom_point(aes(size=density), alpha=1/3)+
  scale_size_area()
```

### 3.5.5 Exercises ###
1. Draw a boxplot of ``hwy`` for each value of ``cyl``, withou turning ``cyl`` into a factor. What extra aesthetic do you need to set?

```{r}
ggplot(mpg, aes(hwy))+
  geom_boxplot()+
  facet_wrap(~cyl)
```


2. Modify the following plot so that you get one boxplot per integer value of ``displ``.

```{r}
ggplot(mpg, aes(displ, cty, group=displ))+
  geom_boxplot()
```

???????????
3. When illustrating the difference between mapping cts and discrete colors to a line, the discrete example needed ``aes(group=1)``. Why? What happens if that is ommitted? What is the difference between ``aes(group=1)`` and ``aes(group=2)``? Why?

```{r}
ggplot(mpg, aes(cyl, hwy, color=cyl))+
  geom_line()

ggplot(mpg, aes(cyl, hwy, color=cyl))+
  geom_line(aes(group=1))

```





4. How many bars are in each of the following plots?
(Hint: try adding an outline around each bar with ``color="white"``)

```{r}



ggplot(mpg, aes(drv))+
  geom_bar(color="white")

# 3 bars


ggplot(mpg, aes(drv, fill=hwy, group=hwy))+
  geom_bar(color="white")

# 3 bars with stakcs (unequal size)

mpg2 = mpg %>% arrange(hwy) %>% mutate(id=seq_along(hwy))

ggplot(mpg2, aes(drv, fill=hwy, group=id))+
  geom_bar(color="white")

# 3 bars with many stacks (equal size)

```

???????????????/
5. Install the babynames package. It contains data about the popularity of babynames in the US. Run the following code and fix the resulting graph. Why does this graph make me unhappy?


```{r}

library(babynames)

# Original Graph
hadley=filter(babynames, name=="Hadley")

ggplot(hadley, aes(year, n))+
  geom_line()

```

The original graph is unclear what information it provides as ``geom_line()`` is not the appropriate geom for this case.

```{r}

# Modified Graph

ggplot(hadley, aes(year, n, color=sex))+
  geom_line()+
  facet_wrap(~sex)

```










## 3.7 Drawing Maps ##
1. __Four Type of Map Data__: 

a. Vector Boundaries

b. Point Metadata

c. Area Metadata

d. Raster Images


### 3.7.1 Vector Boundaries ###

1. __Vector Boundaries__: defined by a data frame with one row for each "corner" of a geographical region like a country, state, or county. 

a. Vector Boundaries requires __four variables__:

(1) __lat__ and (2) __long__: giving the location of a point. 

(2) __group__: a unique identifier for each contiguous region. 

(3) __id__: the name of the region.

b. Separate ``group`` and ``id`` variables are necessary because sometimes a geographical unit is NOT a contiguous polygon. 


__Example__ (Michigan County Map)
```{r}
mi_counties=map_data("county", "michigan") %>%
  select(lon=long, lat, group, id=subregion)

head(mi_counties)

```

c. Visualize vector boundary data with ``geom_polygon()``:

d. __coord_quickmap()__: a quick and dirty adjustment that ensures that the aspect ratio of the plot is set corretly. 

```{r}

ggplot(mi_counties, aes(lon, lat))+
  geom_polygon(aes(group=group))+
  coord_quickmap()

ggplot(mi_counties, aes(lon, lat))+
  geom_polygon(aes(group=group), fill=NA, color="grey50")+
  coord_quickmap()


```

2. Useful Packages

a. __USAboundaries__: contains state, county and zip code data for the US. 

(1) Also contains current boundaries

(2) Also contains state and county boundaries going back to the 1600s. 


b. __tigris__: gives easy access to the US Census TIGRIS shapefiles. It contains state, county, zip-code, and census tract boundaries. 

c. __rnaturalearth__: contains country borders, and borders for the top-level region within each country (e.g. states in the USA, regions in France, counties in the UK).

d. __osmar__: wraps up the __OpenStreetMap API__ so you can access a wide range of vector data including individual streets and buildings. 

e. You may have your own shape files (``.shp``). You can load them into R with ``maptools::readShapeSpatial()``.

3. These sources all generate spatial data frames defined by the __sp__ package.

4. You can convert shape file into a data frame with __fortify()__. 


__Example__ (Use Package USAboundaries)
```{r}
library(USAboundaries)
library(precrec)

c18=us_boundaries(as.Date("1820-01-01"))
 ###?????###
c18df=fortify(c18)

head(c18df)


ggplot(c18df, aes(long, lat))+
  geom_polygon(aes(group=group), color="grey50", fill=NA)+
  coord_quickmap
```



### 3.7.2 Point Metadata ###

1. __Point Metadata__: connects locations (defined by ``lat`` and ``lon``) with other variables. 

```{r}
mi_cities = maps::us.cities %>%
  tbl_df() %>%
  filter(country.etc == "MI") %>%
  select(-country.etc, lon=long) %>%
  arrange(desc(pop))

mi_cities


```

2. You almost always combine point metadata with another layer to make it interpretable. 

```{r}

# Scatterplot of long v.s. lat is NOT very interpretable
ggplot(mi_cities, aes(lon, lat))+
  geom_point(aes(size=pop))+
  scale_size_area()+
  coord_quickmap()


# Adding map layer helps for interpretation

ggplot(mi_cities, aes(lon, lat))+
  geom_polygon(aes(group=group), mi_counties, fill=NA, color="grey50")+
  geom_point(aes(size=pop), color="red")+
  scale_size_area()+
  coord_quickmap()


```





### 3.7.3 Raster Images ###

1. __Raster Image__: draws a traditional map underneath of a given area. 

a. Use __ggmap__ Package: allows you to get data from a variety of online mapping sources including OpenStreetMap and Google Maps. 

b. Downloading the raster data is often time consuming so it's a good idea to cache it in a rds file. 

```{r, eval=FALSE}
if(file.exists("mi_raster.rds")){
  mi_raster=readRDS("mi_raster.rds")
}else{
  bbox=c(
    min(min_counties$lon), min(mi_counties$lat),
    max(mi_counties$lon), max(mi_counties$lat)
  )
  mi_raster=ggmap::get_openstreetap(bbox, scale=8735660)
  saveRDS(mi_raster, "mi_raster.rds")
  
}


```

b. Finding the appropriate ``scale`` required a lot of manual tweaking. You can then plot it with:

```{r, eval=FALSE}
ggmap::ggmap(mi_raster)

ggmap::ggmap(mi_raster)+
  geom_point(aes(size=pop), mi_cities, color="red")+
  scale_size_area()


```


c. To convert raster data you get from the raster package, use the following code:

```{r, eval=FALSE}
df=as.data.frame(raster::rasterToPoints(x))
names(df)=c("lon","lat","x")

ggplot(df,aes(lon, lat))+
  geom_raster(aes(fill=x))
```




### 3.7.4 Area Metadata ###

1. Sometimes metadata s associated NOT with a point, but with an __area__. 

__Example__ (Medata Associated with an Area) 

```{r}
mi_census=midwest %>%
  tbl_df() %>%
  filter(state=="MI") %>%
  mutate(county=tolower(county)) %>%
  select(county, area, poptotal, percwhite, percblack)

mi_census
```

a. We can NOT map this data directly as it has NO spatial component (i.e. no long and lat).

(1) Instead, we must first join it to the vector boundaries data which is not very space efficient but makes it easy to see what data is being plotted. 

(2) Use __dplyr::left_join()__ to combine the two datasets and create a __choropleth__ map. 

```{r}
census_counties=left_join(mi_census, mi_counties, by=c("county"="id"))

census_counties

ggplot(census_counties, aes(lon, lat, group=county))+
  geom_polygon(aes(fill=poptotal))+
  coord_quickmap()

ggplot(census_counties, aes(lon, lat, group=county))+
  geom_polygon(aes(fill=percwhite))+
  coord_quickmap()

```



## 3.8 Revealing Uncertainty ##











































## Reading Quiz 3 ##

Q1
```{r}
x=c(3,6,2,7,5,0,4)
y=c(2,7,4,4,8,2,3)
data=data.frame(cbind(x,y))

ggplot(data, aes(x=x, y=y))+
  geom_line()


ggplot(data, aes(x=x, y=y))+
  geom_path()

ggplot(data, aes(x=x, y=y))+
  geom_area()


ggplot(data, aes(x=x, y=y))+
  geom_polygon()

```


Q3
```{r}
label=c("apple", "banana", "cat", "dog", "eggs", "friend", "grape")

ggplot(data, aes(x,y))+
  geom_text(aes(label=label,
                family=c("serif", "serif", "serif", "serif", "mono", "mono", "mono"),
                vjust="inward",
                hjust="inward"
                
                ))



```

Q7 Bar plots with categorical variables should be arranged by amount from __least to greatest__ or __vice versa__ if there is no order to the categorical variable.

Q8 If one wanted to use a bar graph to understand __a count__, let's say by class year and total, we would use a: __stacked bar plot__.



## Reading Quiz 4 ##

Q2
```{r}
library(maps)
ill=map_data("county", "illinois") %>%
  select(long, lat, group, id=subregion)

ggplot(ill, aes(x=long, y=lat))+
  geom_polygon(aes(group=group), color="purple", fill="white")+
  coord_quickmap()
```



Q3
```{r}
ill_meta=midwest %>%
  tbl_df() %>%
  filter(state=="IL") %>%
  mutate(county=tolower(county)) %>%
  select(county, area, poptotal, popdensity, percpovertyknown, percblack, percasian, percollege) %>%
  left_join(ill, by=c("county"="id"))

ggplot(ill_meta, aes(long, lat, group=county))+
  geom_polygon(aes(fill=percollege))+
  coord_quickmap()
```



Q4

```{r}
diamonds %>%
  group_by(cut) %>%
  summarise(mean_price=mean(price),
            se_price=sd(price)/sqrt(length(price)),
            se_carat=sd(carat)/sqrt(length(carat))) %>%ggplot(aes(cut, mean_price, ymin=mean_price-se_price, ymax=mean_price+se_price))+
  geom_crossbar()


```


Q5

```{r}

ggplot(ill_meta, aes(percollege, percpovertyknown))+
  geom_point(aes(size=popdensity))
 

```

