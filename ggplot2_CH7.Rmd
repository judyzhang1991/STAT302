---
title: "ggplot2_CH7"
author: "Jingyang(Judy) Zhang"
date: "4/27/2020"
output: html_document
---
# CH7 Positioning #

## 7.1 Introduction ##
```{r}
library(tidyverse)
library(reshape)
library(ggpubr)
library(nlme)
library(plyr)

cdc <- read_delim(file = "data_vis_labs/data/cdc.txt", delim = "|") %>%
  mutate(genhlth = factor(genhlth,
    levels = c("excellent", "very good", "good", "fair", "poor")
  ))
```


1. There are four components that control position:

a. __Position Adjustments__: adjust the position of overlapping objects within a layer. These are most useful for bar and other interval geoms, but can be useful in other situations. 

b. __Position Scales__: control how the values in the data are mapped to positions on the plot. 

c. __Facetting__: a mechanis for automatically laying out multiple plots on a page. It splits the data into subsets, and then plots each subset in a different panel. Such plots are often called small multiples or trellis graphics. 

d. __Coordinate Systems__: control how the two independent position scales are combined to create a 2d coordinate system. The most common coordinate system is Cartesian, but other coordinate systems can be useful in special cirucumstances. 

## 7.2 Facetting ##

1. __Facetting__: generates small multiples each showing a different subset of the data. 

a. Small multiples are a powerful tool for exploratory data analysis: you can rapidly compare patterns in different parts of the data and see whether they are the same or different.

2. __Three Types of Facetting__:

a. ``facet_null()``: a single plot, the default.

b. ``facet_wrap()``: "wraps" a 1d ribbon of panels into 2d. 

c. ``facet_grid()``: produces a 2d grid of panels defined by variables which form the rows and columns. 

![](screenshots/ggplot2_figure7_1.png)


### 7.2.1 Facet Wrap ###

1. ``facet_wrap()``: makes a long ribbon of panels (generated by any number of variables) and wraps it into 2d. 
a. Useful when a single variable has many levels and want to arrange the plots in a more space efficient manner. 

b. Control how the ribbon is wrapped into a grid:

(1) ``dir.ncol`` and ``nrow``: control how many columns and rows (you only need to set one). 

(2) ``as.table``: controls whether the facets are laid out like a table (TRUE), with highest values at the bottom right, or a plot (FALSE), with the highest values at the top-right. 

(3) ``dir``: controls the direction of wrap: horizontal or vertical

```{r}
base <- ggplot(mpg, aes(displ, hwy)) +
  geom_blank() +
  xlab(NULL) +
  ylab(NULL)

base + facet_wrap(~class, ncol = 3)

base + facet_wrap(~class, ncol = 3, as.table = FALSE)


base + facet_wrap(~class, nrow = 3)

base + facet_wrap(~class, nrow = 3, dir = "v")
```



### 7.2.2 Facet Grid ###

1. ``facet_grid()``: lays out plots in a 2d grid, as defined by a formula:

a. ``. ~ a``: spreads the values of ``a`` across the columns. This direction facilitates comparisons of ``y`` position, because the vertical sclaes are aligned. 

```{r}
base + facet_grid(.~ cyl)

```

b. ``b ~ .``: spreads the values of ``b`` down the rows. This direction facilitates comparison of ``x`` poisition because the horziontal scales are aligned. This makes it particularly useful for comparing distributions. 

```{r}
base + facet_grid(drv ~ .)
```


c. ``a ~ b``: spreads ``a`` across columns and ``b`` down rows. Usually want to put the variable with the greatest number of levels in the columns, to take advantage of the aspect ratio of your screen. 

```{r}
base + facet_grid(drv ~ cyl)
```


d. ``a + b ~ c + d``: can use multiple variables in the rows or columns by "adding" them together. 

(1) Variables appearing together on the rows or columns are nested in the sense that only combinations that appear in the data will appear in the plot.

(2) Variables that are specified on rows and columns will be crossed: all combinations will be shown, including those that didnt appear in the original dataset: this may result in empty panels. 


### 7.2.3 Controlling Scales ##
1. For both ``facet_wrap()`` and ``facet_grid()`` you can control whether the position scales are the same in all panels (__fixed__) or allow to vary between panels (__free__) with the __scale__ paramter:

a. ``scales = "fixed"``: ``x`` and ``y`` scales are fixed across all panels. 

b. ``scales = "free_x"``: the ``x`` scale is free, and the ``y`` scale is fixed. 

c. ``scales = "free_y"``: the ``y`` scale is free, and the ``x`` scale is fixed. 

d. ``scales = "free"``: ``x`` and ``y`` scales vary across panels. 

2. ``facet_grid()`` imposes an additional constraint on the scales: ALL panels in a __column__ must have the SAME X SCALE, and ALL palnels in a __row__ must have the SAME Y SCALE. This is because each column shares ONE ``x`` axis, and each row shares ONE ``y`` axis. 

3. __Fixed scales__ make it easier to see patterns across panels; __Free scales__ make it easir to see patterns within panels. 

```{r}
p <- ggplot(mpg, aes(cty, hwy)) + 
  geom_abline() +
  geom_jitter(width = 0.1, height = 0.1)

p + facet_wrap(~cyl)

p + facet_wrap(~cyl, scales = "free")

```


4. __Free scales__ are also useful when display multiple time series that were measured on different scales. 

```{r}
ggplot(economics_long, aes(date, value)) +
  geom_line() +
  facet_wrap(~variable, scales = "free_y", ncol = 1)
```


5. __Space__: an additional parameter in ``facet_grid()``. ``space`` takes the same values as ``scales`` (i.e. "free" and "fixed"). 

a. When ``space`` is "free", each column or row will have width or height proportional to the range of the scale for that column or row. This makes the scaling equal across the who plot: 1 cm on each panel maps to the same range of data. 
(1) Example: panel ``a`` had range 2 and panel ``b`` had range 4: $\frac{1}{3}$ of the space would be given to ``a``, and $\frac{2}{3}$ of the space would be given to ``b``. 

(2) This is most useful for categorical scales, where we can assign space proportionally based on the number of levels in each facet. 

```{r}
mpg$model <- reorder(mpg$model, mpg$cty)

mpg$manufacturer <- reorder(mpg$manufacturer, -mpg$cty)

ggplot(mpg, aes(cty, model)) +
  geom_point() +
  facet_grid(manufacturer ~ ., scales = "free", space = "free") +
  theme(strip.text.y = element_text(angle = 0))
```




### 7.2.4 Missing Facetting Variables ###

1. One of datasets with missing the facetting variables:
ggplot will display the map in every facet: missing facetting variables are treated like they have all values. 

__Example__: (Missing Facetting Variables)

```{r}
df1 <- data.frame(x = 1:3, y = 1:3, gender = c("f", "f", "m"))

df2 <-data.frame(x = 2, y = 2)

ggplot(df1, aes(x, y)) +
  geom_point(data = df2, color = "red", size =2) +
  geom_point() +
  facet_wrap(~gender)
```

a. This technique is particularly useful when you add annotations to make it easier to compare between facets. 


### 7.2.5. Grouping vs. Facetting ###

1. __Facetting__ is an alternative to using __aesthetics__ (like color, shape or size) to different groups.

a. With facetting: each group is quite far apart in its own panel, and there is no overlap between the groups. 

(1) This if group if the groups overlap a lot, but it does make smale differences harder to see. 

b. With using aesthetics to different groups: the groups are close together and may overlap, but small differences are easier to see. 

2. Comparison between facets often benefit from:

a. Some thoughtful annotation. 

__Example__: (Show the mean of each group in every panel)

```{r, eval = FALSE}
df <- data.frame(
  x = rnorm(120, c(0, 2, 4)), 
  y = rnorm(120, c(1, 2, 1)), 
  z = letters[1:3]
)

df_sum <- df %>%
  group_by(z) %>%
  summarise(x = mean(x), y = mean(y)) %>%
  rename(z2 = z)


ggplot(df, aes(x, y)) +
  geom_point() +
  geom_point(data = df_sum, aes(color = z2), size = 4) +
  facet_wrap(~z)

```


b. Put all the data in the background of each panel:

```{r}
df2 <- select(df, -z)

ggplot(df, aes(x, y)) +
  geom_point(data = df2, color = "grey70") +
  geom_point(aes(color = z)) + 
  facet_wrap(~z)
```


### 7.2.6 Continuous Variables ###

1. To facet continuous variables, you must first discretise them. 

a. There are three helper functions to do:

(1) __cut_interval(x, n)__: divide the data into ``n`` bins each of the same length. 

(2) __cut_wdith(x, width)__: divide the data into bins of width ``width``. 

(3) __cut_number(x, n = 10): divide the data into ``n`` bins each containing (approximately) the same number of points. 

__Example__: (Bins of width 1; six bins of equal length, six bins containing equal numbers of bins)
```{r}
mpg$disp_w <- cut_width(mpg$displ, 1)

mpg$disp_i <- cut_interval(mpg$displ, 6)

mpg$disp_n <- cut_number(mpg$displ, 6)


plot <- ggplot(mpg, aes(cty, hwy)) + 
  geom_point() +
  labs(x = NULL, y = NULL)

plot + facet_wrap(~disp_w, nrow = 1)

plot + facet_wrap(~disp_i, nrow = 1)

plot + facet_wrap(~disp_n, nrow = 1)




```


b. Note that the facetting formula does NOT evaluate functions, so you must first create a new variable containing the discretised data. 

###



## 7.3 Coordinate Systems ##

1. Coordinates systems have two main jobs: 

a. Combine the two position aesthetics to produce a 2d position on the plot. 

(1) The position aesthetics are called ``x`` and ``y``, but they might be better called position 1 and 2 because their meaning depends on the corrdinate system used. 

(a) Polar Coordinate System: angle and radius. 

(b) Map Coordinate System: latitude and longitude. 

b. In coordination with the faceter, coordinate systems draw axes and panel backgrouns. 

(1) While the scales control the values that appear on the axes, and how they map from data to position, it is the coordinate system which actually draws them. 

(2) This is because their appearance depends on the coordinate system: an angle axis looks quite different than an x axis. 


2. There are two types of coordinate system:

a. __Linear Coordinate Systems__: preserve the shape of geoms:

(1) __coord_cartesian()__: the default Cartesian coordinate system, where the 2d position of an element is given by the combination of the ``x`` and ``y`` positions. 

(2) __coord_flip()__: Cartesian coordinate system with ``x`` and ``y`` axes flipped. 

(3) __coord_fixed()__: Cartesian coordinate system with a fixed aspect ratio. 


b. __Non-linear Coordinate Systems__: can change the shapes: a straight line may no longer be straight. The closest distance between two points may no longer be a straight line. 

(1) __coord_map()/coord_quickmap()___: map projections. 

(2) __coord_polar()__: polar coordinates. 

(3) __coord_trans()__: apply arbitrary transformations to ``x`` and ``y`` positions, after the data has been processed by the stat. 




## 7.4 Linear Coordinate Systems ##


1. There are three linear coordiante systems: ``coord_cartesian()``, ``coord_flip()``, ``coord_fixed()``. 

### 7.4.1 Zoooming into a Plot with coord_cartesain() ###

1. __coord_cartesian()__: has arguments ``xlim`` and ``ylim``. 

a. Compare with the limits argument of the scales:

(1) When setting scale limits, any data outside the limits is thrown away

(2) Setting coordinate system limits we still use all the data, but we only display a small region of the plot. Setting coordinate system limits is like looking at the plot under a magnifying glass. 


__Example__: (Compare setting limits with scales and with coordinates)

```{r}
base <- ggplot(mpg, aes(displ, hwy)) + 
  geom_point()+
  geom_smooth()



# Full data
base


# Scaling to 5 -- 7 throws away data outside that range
base + scale_x_continuous(limits = c(5, 7))

# Zooming to 5 -- 7 keeps all the data but only shows some of it

base + coord_cartesian(xlim = c(5, 7))


```


### 7.4.2 Flipping the Axes with coord_flip() ###

1. Most statistics and geoms assume you are interested in ``y`` values conditional on ``x`` values (e.g., smooth, summary, boxplot, line): in most statistical models, the ``x`` values are assumed to be measured without error. 

2. If interested in ``x`` conditional on ``y`` (or you just want to rotate the plot 90 degrees), you can __coord_flip()__ to exchange the ``x`` and ``y`` axes. 


__Example__: (Compare flip coordinates with exchange variables mapped to ``x`` and ``y``)

```{r}
ggplot(mpg, aes(displ, cty)) +
  geom_point() +
  geom_smooth()

# Exchanging cty and displ rotates the plot 90 degrees, but the smooth is fit to the rotate data

ggplot(mpg, aes(cty, displ)) +
  geom_point() +
  geom_smooth()

# coord_flip() fits the smooth to the original data, and then rotates the output

ggplot(mpg, aes(displ, cty)) +
  geom_point() +
  geom_smooth() +
  coord_flip()
```







## Reading Quiz 7 ##


Q1
```{r}
ggplot(cdc, aes(height, weight)) +
  geom_point() +
  facet_wrap(~genhlth, ncol = 2, dir = "v")
  
```



Q2
```{r}
# Option 1
ggplot(cdc, aes(height, weight)) +
  geom_point() +
  facet_grid(genhlth ~ smoke100)


# Option 2
ggplot(cdc, aes(height, weight)) +
  geom_point() +
  facet_grid(smoke100 ~ genhlth)


# Option 3
ggplot(cdc, aes(height, weight)) +
  geom_point() +
  facet_grid(genhlth ~ smoke100, scale = "free")


# Option 2
ggplot(cdc, aes(height, weight)) +
  geom_point() +
  facet_grid(smoke100 ~ genhlth, scale = "free")

  
```


Q4

```{r}
cdc2 <- dplyr::select(cdc, -gender)

ggplot(cdc, aes(height, weight)) +
  geom_point(data = cdc2, color = "grey70") +
  geom_point(aes(color = gender)) + 
  facet_wrap(~gender)
```




Q5
```{r}
ggplot(cdc, aes(weight, wtdesire)) + 
  geom_point() +
  geom_smooth()


# Option 1: x and y aesthetic switched
ggplot(cdc, aes(wtdesire, weight)) + 
  geom_point() +
  geom_smooth()


# Option 2: Coord flipped
ggplot(cdc, aes(weight, wtdesire)) + 
  geom_point() +
  geom_smooth() + 
  coord_flip()
```



### 7.4.3 Equal Scales with coord_fixed() ###

1. __coord_fixed()__: fixes the ratio of length on the ``x`` and ``y`` axes. The default ``ratio`` ensures that the ``x`` and ``y`` axes have equal scales: i.e. 1 cm along the ``x`` axis represents the same range of data as 1cm along the ``y`` axis. 

a. The aspect ratio will also be set to ensure that the mapping is maintained regardless of the shape of the output device. 


## 7.5. Non-linear Coordinate Systems ##

1. __Non-linear Coordinates__: can change the shape of geoms. 

a. __Polar Coordinate__: a rectangles becomes an arc. 

b. __Map Projection__: the shortest path between two points is NOT necessarily a straight line. 

__Example__: (Rectangle rendered in a few different coordinate sysmtes)

```{r}
rect <- data.frame(x = 50, y = 50)

line <- data.frame(x = c(1, 200), y = c(100, 1))

base <- ggplot(mapping = aes(x, y)) + 
  geom_tile(data = rect, aes(width = 50, hegith = 50)) +
  geom_line(data = line) +
  xlab(NULL) + ylab(NULL)


base

base + coord_polar("x")

base + coord_polar("y")

base + coord_flip

base + coord_trans(y = "log10")

base + coord_fixed()

```


